<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Marble Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #controls {
      padding: 10px 50px;
      background-color: #eee;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    #controls button {
      margin-right: 10px;
    }
    canvas {
      display: block;
      border: 1px solid #000;
      margin: 20px 50px;
      background-color: #f9f9f9;
    }
  </style>
</head>
<body>
  <div id="controls">
    <span id="marbleCounter">Used: 0 | Left: 9 | Total: 9</span><br><br>
    <button onclick="resetMarbles()">Reset</button>
    <button onclick="activateRemoveMode()">Remove 1 Marble</button>
    <button onclick="activateMoveMode()">Move Marble</button>
  </div>
  <canvas id="gridCanvas" width="700" height="500"></canvas>
  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");

    const gridCols = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
    const gridRows = ['1', '2', '3', '4', '5'];
    const spacingX = 100;
    const spacingY = 100;
    const offsetX = 50;
    const offsetY = 50;

    const points = {};
    const marbleRadius = 10;
    let marbles = [];
    let maxMarbles = 9;
    let mode = 'normal';
    let moveFrom = null;

    function updateCounter() {
      document.getElementById("marbleCounter").textContent = `Used: ${marbles.length} | Left: ${maxMarbles - marbles.length} | Total: ${maxMarbles}`;
    }

    function getCoord(col, row) {
      return [offsetX + col * spacingX, offsetY + row * spacingY];
    }

    gridCols.forEach((colLetter, colIdx) => {
      gridRows.forEach((rowNumber, rowIdx) => {
        const label = `${colLetter}${rowNumber}`;
        points[label] = getCoord(colIdx, rowIdx);
      });
    });

    const diagonalIntersections = ['C2', 'E2', 'E4', 'C4'];
    const squarePath = ['B1', 'F1', 'F5', 'B5'];

    function drawGridLines() {
      ctx.strokeStyle = "#ddd";
      for (let i = 0; i < gridCols.length; i++) {
        ctx.beginPath();
        ctx.moveTo(offsetX + i * spacingX, offsetY);
        ctx.lineTo(offsetX + i * spacingX, offsetY + (gridRows.length - 1) * spacingY);
        ctx.stroke();
      }
      for (let i = 0; i < gridRows.length; i++) {
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY + i * spacingY);
        ctx.lineTo(offsetX + (gridCols.length - 1) * spacingX, offsetY + i * spacingY);
        ctx.stroke();
      }
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGridLines();

      ctx.beginPath();
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.moveTo(...points["A1"]);
      ctx.lineTo(...points["G1"]);
      ctx.lineTo(...points["G5"]);
      ctx.lineTo(...points["A5"]);
      ctx.closePath();
      ctx.stroke();

      ctx.beginPath();
      ctx.strokeStyle = "orange";
      squarePath.forEach((pt, idx) => {
        if (idx === 0) {
          ctx.moveTo(...points[pt]);
        } else {
          ctx.lineTo(...points[pt]);
        }
      });
      ctx.closePath();
      ctx.stroke();

      ctx.strokeStyle = "purple";
      ctx.beginPath();
      ctx.moveTo(...points["A1"]);
      ctx.lineTo(...points["G5"]);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(...points["G1"]);
      ctx.lineTo(...points["A5"]);
      ctx.stroke();

      const center = points["D3"];
      const radius = Math.hypot(center[0] - points["D1"][0], center[1] - points["D1"][1]);
      ctx.strokeStyle = "green";
      ctx.beginPath();
      ctx.arc(center[0], center[1], radius, 0, 2 * Math.PI);
      ctx.stroke();

      ctx.fillStyle = "black";
      ctx.font = "12px Arial";
      for (const label in points) {
        const [x, y] = points[label];
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillText(label, x + 5, y - 5);
      }

      ctx.fillStyle = "red";
      diagonalIntersections.forEach(label => {
        const [x, y] = points[label];
        ctx.fillText("*", x - 4, y + 4);
      });

      drawMarbles();
      updateCounter();
    }

    function drawMarbles() {
      ctx.fillStyle = "orange";
      marbles.forEach(m => {
        const [x, y] = m.includes(',') ? m.split(',').map(Number) : points[m];
        ctx.beginPath();
        ctx.arc(x, y, marbleRadius, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    function getClickedPoint(x, y) {
      for (const label in points) {
        const [px, py] = points[label];
        const dist = Math.hypot(px - x, py - y);
        if (dist <= marbleRadius * 1.5) {
          return label;
        }
      }

      const center = points["D3"];
      const radius = Math.hypot(center[0] - points["D1"][0], center[1] - points["D1"][1]);
      const distToCenter = Math.hypot(center[0] - x, center[1] - y);
      if (Math.abs(distToCenter - radius) <= marbleRadius * 1.5) {
        return `${x},${y}`;
      }

      return null;
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const clickedLabel = getClickedPoint(x, y);
      if (!clickedLabel) return;

      if (mode === 'remove') {
        const index = marbles.indexOf(clickedLabel);
        if (index !== -1) {
          marbles.splice(index, 1);
          drawGrid();
          mode = 'normal';
        }
      } else if (mode === 'move') {
        if (!moveFrom) {
          if (marbles.includes(clickedLabel)) {
            moveFrom = clickedLabel;
          }
        } else {
          const index = marbles.indexOf(moveFrom);
          if (index !== -1) {
            marbles[index] = clickedLabel;
            moveFrom = null;
            mode = 'normal';
            drawGrid();
          }
        }
      } else {
        const index = marbles.indexOf(clickedLabel);
        if (index === -1 && marbles.length < maxMarbles) {
          marbles.push(clickedLabel);
        } else if (index !== -1) {
          marbles.splice(index, 1);
        } else if (index === -1 && marbles.length >= maxMarbles) {
          alert("Maximum marbles placed. Remove one to move.");
        }
        drawGrid();
      }
    });

    function resetMarbles() {
      marbles = [];
      drawGrid();
    }

    function activateRemoveMode() {
      mode = 'remove';
      alert("Click a marble to remove it.");
    }

    function activateMoveMode() {
      mode = 'move';
      moveFrom = null;
      alert("Click the marble to move, then click the target location.");
    }

    drawGrid();
  </script>
</body>
</html>
